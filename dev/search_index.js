var documenterSearchIndex = {"docs":
[{"location":"graph/#Hypergraph-Types","page":"Hypergraph","title":"Hypergraph Types","text":"","category":"section"},{"location":"graph/#Introduction","page":"Hypergraph","title":"Introduction","text":"","category":"section"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"This file describes a graph structure inspired by MathOptInterface. The structure is used to find the shortest path in the hypergraph of function call bridges in a type-stable manner. To be precise, we want to enable inter-dependent fallbacks for certain function calls with known argument types.","category":"page"},{"location":"graph/#Method-Implementation-Trait","page":"Hypergraph","title":"Method Implementation Trait","text":"","category":"section"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Whether or not a suitable method exists is indicated with a trait:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"abstract type AbstractImplementedTrait end\nstruct IsImplemented <: AbstractImplementedTrait end\nstruct NotImplemented <: AbstractImplementedTrait end","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"The trait is queried with is_implemented:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"@nospecialize\nis_implemented(func, args_Type)=NotImplemented()\n@specialize","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"This trait function can be specialized. It falls back to checking if an applicable method exists (statically, thanks to Tricks.jl)","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"@nospecialize\nfunction is_implemented(\n    func::func_Type,\n    args_Type::Type{<:Tuple}\n) where func_Type <: Function\n    if _applicable(func, args_Type)\n        return IsImplemented()\n    else\n        return NotImplemented()\n    end\nend\n@specialize","category":"page"},{"location":"graph/#The-Hypergraph-of-Bridges","page":"Hypergraph","title":"The Hypergraph of Bridges","text":"","category":"section"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"The requested function calls can be thought of as vertices in a directed hypergraph. More precisely, vertices in an F-graph. Fallback bridges are then hyper-edges, starting in a function call vertex and pointing to other vertices that enable the fallback calculations.","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"NoteIn certain situations, a bridge can itself perform all the necessary operations based on information inferred from the argument types. Then the hyper-edge points to \"virtual\" vertices, which are just assumed to be implemented.","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"The hypergraph idea allows us to compute shortest bridging paths. But to do so quickly, we don't store the actual func-arg types or bridge types in the graph structure. Instead, we take inspiration from MathOptInterface.","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"A simple node type just wrapping an index:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"\"Node(index::Int)\"\nstruct Node\n    \"Integer index. Either `0` or an index into arrays within a `Graph` object.\"\n    index :: Int\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"The hyper-edge type also stores source information, but also indicates the successor nodes and a cost:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"\"Edge(bridge_index::Int, added_nodes::Vector{Node}, cost::Float64)\"\nstruct Edge\n    \"Integer index of bridge inducing this edge in some sorted iterable of bridges.\"\n    bridge_index :: Int\n    \"Successor nodes this hyper-edge is pointing to.\"\n    added_nodes :: Vector{Node}\n    \"Briding cost for shortest path calculation\"\n    cost :: Float64\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"The graph has only a few fields needed for shortest path computation. There is no list of nodes, but a dict mapping function calls to respective nodes is stored in a BridgedWrapper. For shortest path algorithm to work, the node information stored in the edges is sufficient.","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"@kwdef struct Graph\n    edges :: Vector{Vector{Edge}} = []\n    dist :: Vector{Float64} = []\n    last_correct_ref :: Base.RefValue{Int} = Ref(0)\n    best :: Vector{Int} = []\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Helper to reset a graph:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function Base.empty!(graph::Graph)\n    @unpack edges, dist, best, last_correct_ref = graph\n    empty!(edges)\n    empty!(dist)\n    empty!(best)\n    last_correct_ref[] = 0\n    return graph\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Helper to add a new node and return it:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function add_node!(graph)\n    @unpack edges, dist, best = graph\n    push!(edges, Edge[])\n    push!(best, 0)\n    push!(dist, Inf)\n    return Node(length(dist))\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Helper for pushing an edge starting at node:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function add_edge!(graph, node, edge)\n    push!(graph.edges[node.index], edge)\n    return edge\nend","category":"page"},{"location":"graph/#Bellman-Ford-–-Shortest-Path","page":"Hypergraph","title":"Bellman Ford – Shortest Path","text":"","category":"section"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"The best bridge is available in graph.best after shortest path search:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function bridge_index(graph::Graph, n::Node)\n    _bellman_ford!(graph)\n    return graph.best[n.index]\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"The implementation is adapted from MathOptInterface:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function _bellman_ford!(graph::Graph)\n    @unpack best, last_correct_ref = graph\n    lc = last_correct_ref[]","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Has a distance changed in the last iteration?","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"    changed = true\n    while changed\n        changed = false\n        for i in (lc+1):length(best)\n            dist, best_index = _updated_dist(\n                graph,\n                graph.dist[i],\n                graph.edges[i],\n            )\n            if !iszero(best_index)\n                graph.dist[i] = dist\n                graph.best[i] = best_index\n                changed = true\n            end\n        end\n    end\n    last_correct_ref[] = length(best)\n    return graph\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Helper to update distance estimate for a node with current distance current and leaving hyper-edges edges:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function _updated_dist(\n    graph::Graph,\n    current::Float64,\n    edges::Vector{Edge},\n)\n    bridge_index = 0\n    for edge in edges\n        dist = _dist(graph, edge)\n        if isinf(dist)\n            continue\n        end\n        dist += edge.cost\n        if dist < current\n            current = dist\n            bridge_index = edge.bridge_index\n        end\n    end\n    return current, bridge_index\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Return cumulative distance for all successor nodes:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function _dist(graph::Graph, edge::Edge)\n    return _dist(graph, edge.added_nodes)\nend\n\nfunction _dist(graph::Graph, nodes::Vector{<:Node})\n    dist = 0\n    for node in nodes\n        d = _dist(graph, node)\n        if isinf(d)\n            return d\n        end\n        dist += d\n    end\n    return dist\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"Distance for a single node:","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"function _dist(graph::Graph, node::Node)\n    ni = node.index\n    # zero-index: implemented function call ⇒ no cost\n    return iszero(ni) ? 0 : graph.dist[ni]\nend\n\n# Helpers to allow insertion into `Dict{Tuple{Type,Type}, Something}`\n# without giving the type of the function `func` as argument, but rather function itself.\n# We use the helper and this kind of dict, because operations on a dict\n# `Dict{Tuple{Function, Type}, Something}` are rather slow.\n# The helper has `@nospecialize` to avoid costly re-compilations for different functions:\nfunction _insert!(dict, @nospecialize(func::func_Type), @nospecialize(args_Type), val) where func_Type\n    dict[(func_Type, args_Type)] = val\n    return val\nend\n\n# Similar helper to obtain values from dict:\nfunction _get(dict, @nospecialize(func::func_Type), @nospecialize(args_Type), default) where func_Type\n    return get(dict, (func_Type, args_Type), default)\nend","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"","category":"page"},{"location":"graph/","page":"Hypergraph","title":"Hypergraph","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bridging_interface/#Bridges","page":"Bridging","title":"Bridges","text":"","category":"section"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"Every bridge has to subtype AbstractBridge:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"abstract type AbstractBridge end","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"For the shortest-path computation(s) in the bridging hyper-graph, the following methods should be implemented.","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"@nospecialize\nfunction is_implemented(\n    bridge::AbstractBridge, func::func_Type, args_Type::Type{<:Tuple}\n) where func_Type <: Function\n    return NotImplemented()\nend\nfunction required_funcs_with_argtypes(\n    bridge::AbstractBridge, func::func_Type, args_Type::Type{<:Tuple}\n) where func_Type <: Function\n    return ()\nend\n@specialize","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"Optionally, define a bridging cost:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"@nospecialize\nfunction bridging_cost(\n    bridge::AbstractBridge, func::func_Type, args_Type::Type{<:Tuple}\n) where func_Type <: Function\n    return 1.0\nend\n@specialize","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"NoteWe use args_Type instead of args... here to enable investigating the graph without allocations. It is certainly more prohibitive because we must be able to infer enough information from types alone. But for now it appears sufficient.","category":"page"},{"location":"bridging_interface/#BridgedWrapper","page":"Bridging","title":"BridgedWrapper","text":"","category":"section"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"To enable bridges, implement all_bridges to return objects with types that subtype AbstractBridge:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"all_bridges(obj) = ()","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"This then enables us to build a minimal wrapper storing all the bridges, a type-stable graph, and a dict for quick retrieval of nodes for specific function calls (based on the call signature). BridgedWrapper is loosely inspired by the LazyBridgeOptimizer in MathOptInterface.","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"@kwdef struct BridgedWrapper{bridges_Type}\n    bridges :: bridges_Type\n    graph :: Graph = Graph()\n    node_dict :: Dict{Tuple{Type, Type}, Node} = Dict{Tuple{Type, Type}, Node}()\nend\nBridgedWrapper(obj) = BridgedWrapper(; bridges = all_bridges(obj))","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"More compact printing:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function Base.show(io::IO, bw::BridgedWrapper)\n    println(io, \"BridgedWrapper(:bridges($(length(bw.bridges))), :graph, :node_dict)\")\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"Helper for resetting a wrapper. (We don't really support dynamically adding bridges as of yet.)","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function reset!(bw::BridgedWrapper)\n    empty!(bw.graph)\n    empty!(bw.node_dict)\n    return bw\nend","category":"page"},{"location":"bridging_interface/#Adding-Nodes-to-Wrapped-Graph","page":"Bridging","title":"Adding Nodes to Wrapped Graph","text":"","category":"section"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"A node is only added for unimplemented function call signatures.","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function node(\n    bw::BridgedWrapper, @nospecialize(func::func_Type), @nospecialize(args_Type::Type)\n) where func_Type <: Function\n    return node(is_implemented(func, args_Type), bw, func, args_Type)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"IsImplemented, return trivial node:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function node(\n    bw_impls_func::IsImplemented,\n    bw::BridgedWrapper, @nospecialize(func::func_Type), @nospecialize(args_Type)\n) where func_Type <: Function\n    return Node(0)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"NotImplemented, actually add a node to the graph:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function node(\n    bw_impls_func::NotImplemented,\n    bw::BridgedWrapper, @nospecialize(func::func_Type), @nospecialize(args_Type)\n) where func_Type <: Function\n    @unpack bridges, graph, node_dict = bw\n    # is node already in graph?\n    nd = _get(node_dict, func, args_Type, nothing)\n    if !isnothing(nd)\n        return nd\n    end\n    # create new node\n    nd = add_node!(graph)\n    # also store in dict\n    _insert!(node_dict, func, args_Type, nd)\n\n    # check if it is supported by any bridges:\n    for (i, bridge) = enumerate(bridges)\n        _maybe_add_bridge!(bw, nd, func, args_Type, i, bridge)\n    end\n    return nd\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"Like with nodes, bridges/edges are only added if they support a certain function call.","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function _maybe_add_bridge!(\n    bw, nd, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge\n) where func_Type\n    is_implemented(bridge, func, args_Type)\n    return _maybe_add_bridge!(\n        is_implemented(bridge, func, args_Type), bw, nd, func, args_Type, i, bridge)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"NotImplemented, do nothing:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function _maybe_add_bridge!(\n    bridge_impls_func::NotImplemented,\n    bw, nd, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge\n) where func_Type\n    return bw\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"IsImplemented, add hyper-edge to wrapped graph:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function _maybe_add_bridge!(\n    bridge_impls_func::IsImplemented,\n    bw, nd, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge\n) where func_Type\n    e = _edge(bw, func, args_Type, i, bridge)\n    add_edge!(bw.graph, nd, e)\n    return bw\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"Helper to also add successor nodes; this is where recursion becomes obvious:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function _edge(\n    bw, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge\n) where func_Type\n    new_nodes = Node[\n        node(bw, _func, _args_Type)\n            for (_func, _args_Type) = required_funcs_with_argtypes(bridge, func, args_Type)\n    ]\n    bc = bridging_cost(bridge, func, args_Type)\n    edge = Edge(i, new_nodes, bc)\n    return edge\nend","category":"page"},{"location":"bridging_interface/#Preparation-and-Computation","page":"Bridging","title":"Preparation and Computation","text":"","category":"section"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"When everything is set up, there is a two-stage execution procedure to actually perform a queried function call. First, some AbstractPreparation is instantiated. This object is then used to execute the function calls – with varying argument values (but not varying types or sizes). This is very similar to how DifferentiationInterface works. In fact, the fact that prep takes args... instead of args_Type is to enable bridges using DifferentiationInterface. (Otherwise, prep would also resemble concrete_bridge_type in MathOptInterface.)","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"abstract type AbstractPreparation end","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"For a bridge to work, prep has to be specialized and return some AbstractPreparation object. The argument bw is needed to prepare successor calls/bridges:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"@nospecialize\nfunction prep(\n    bridge::AbstractBridge, bw::BridgedWrapper, func::func_Type, args...\n) where func_Type <: Function\n    error(\"`prep` not implemented for `$(bridge)` and `$(func)`.\")\nend\n@specialize","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"Then, compute! has to be specialized to return the value for args...:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"@nospecialize\nfunction compute!(prep::AbstractPreparation, args...)\n    error(\"`compute!` not implemented for `$(prep)`.\")\nend\n@specialize","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"We can derive a compact helper:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function bridged_compute!(\n    bw::BridgedWrapper, @nospecialize(func::func_Type), args...\n) where func_Type <: Function\n    p = prep(bw, func, args...)\n    return compute!(p, args...)\nend","category":"page"},{"location":"bridging_interface/#Default-Preparation-Objects","page":"Bridging","title":"Default Preparation Objects","text":"","category":"section"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"When there is no path in the hyper-graph, an UnsuccessfulPrep is returned:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"@kwdef struct UnsuccessfulPrep <: AbstractPreparation\n    msg :: Union{Nothing, String} = nothing\nend\n\nfunction UnsuccessfulPrep(@nospecialize(func::Function))\n    msg = \"Call to `$(func)` not possible.\"\n    UnsuccessfulPrep(; msg)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"It just errors:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function compute!(p::UnsuccessfulPrep, @nospecialize(args...))\n    _compute_unsucc_prep(p.msg)\nend\n_compute_unsucc_prep(msg::String)=throw(ErrorException(msg))\n_compute_unsucc_prep(::Nothing)=error(\"`compute!` not applicable for `UnsuccessfulPrep`.\")","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"If a function call is supported, then we just wrap the function:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"struct FuncPrep{func_Type} <: AbstractPreparation\n    func :: func_Type\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"This enables us to specialize compute! based on dispatch:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function compute!(@nospecialize(prep::FuncPrep), args...)\n    @unpack func = prep\n    return _compute_func_prep(func, args)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"In the end, we just invoke the function with arguments args:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function _compute_func_prep(@nospecialize(func::func_Type), args::args_Type) where {func_Type, args_Type}\n    return invoke(func, args_Type, args...)\nend","category":"page"},{"location":"bridging_interface/#Graph-Backed-Preparation","page":"Bridging","title":"Graph-Backed Preparation","text":"","category":"section"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"For a function call, a node is added (lazily), the shortest path is calculated (lazily), and a corresponding AbstractPreparation object is returned:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function prep(\n    bw::BridgedWrapper, @nospecialize(func::func_Type), args...\n) where {func_Type<:Function}\n    args_Type = typeof(args)\n    n = node(bw, func, args_Type)\n    if iszero(n.index)\n        return FuncPrep(func)\n    end\n    _bellman_ford!(bw.graph)\n    if isinf(bw.graph.dist[n.index])\n        return UnsuccessfulPrep(func)\n    end\n    return prep_node(bw, n, func, args...)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"prep_node is just a helper around prep for the best bridge (currently):","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function prep_node(\n    bw::BridgedWrapper, n::Node, @nospecialize(func::func_Type), args...\n) where {func_Type<:Function}\n    bi = bw.graph.best[n.index]\n    b = bw.bridges[bi]\n    p = prep(b, bw, func, args...)\n    return _prep_node(p, bw, n, func, args...)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"If preparation was successful, return p:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"@nospecialize\nfunction _prep_node(\n    p::AbstractPreparation, bw::BridgedWrapper, n::Node, func::func_Type, args...\n) where {func_Type<:Function}\n    return p\nend\n@specialize","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"Otherwise, invalidate bridge and try again:","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"function _prep_node(\n    @nospecialize(p), bw::BridgedWrapper, n::Node, @nospecialize(func::func_Type), args...\n) where {func_Type<:Function}\n    ni = n.index\n    bi = bw.graph.best[n.index]\n    @unpack graph = bw\n    es = graph.edges[ni]\n    @debug \"Invalidating bridge $bi for node with index $ni.\"\n    for (i, e) in enumerate(es)\n        if e.bridge_index == bi\n            _e = @set e.cost = Inf\n            deleteat!(es, i)\n            insert!(es, i, _e)\n            # TODO modifying an array during iteration is dangerous\n            #      alternative: make `Edge` mutable?\n        end\n    end\n    graph.dist[ni] = Inf\n    graph.last_correct_ref[] = ni - 1\n    return prep(bw, func, args...)\nend","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"","category":"page"},{"location":"bridging_interface/","page":"Bridging","title":"Bridging","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#MOPEDS","page":"Home","title":"MOPEDS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MOPEDS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All docstrings:","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#MOPEDS.Edge","page":"Home","title":"MOPEDS.Edge","text":"Edge(bridgeindex::Int, addednodes::Vector{Node}, cost::Float64)\n\n\n\n\n\n","category":"type"},{"location":"#MOPEDS.Node","page":"Home","title":"MOPEDS.Node","text":"Node(index::Int)\n\n\n\n\n\n","category":"type"},{"location":"#MOPEDS.static_which-Tuple{Any}","page":"Home","title":"MOPEDS.static_which","text":"static_which(f, [type_tuple::Type{<:Tuple}, throw_error::Union{Val{true}, Val{false}}])\n\nSimilar to Base.which this returns the method of f that would be used by invoke for  the given argument type tuple. If throw_error==Val(true), then an error is thrown if no suitable method is found. If throw_error==Val(false) and there is no method, then nothing is returned. Default is throw_error=Val(false).\n\n\n\n\n\n","category":"method"},{"location":"problem_interface/#Draft-of-Problem-Interface","page":"Problem Interface","title":"Draft of Problem Interface","text":"","category":"section"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Problems must subtype AbstractProblem.","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"abstract type AbstractProblem end","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"The problem type should indicate what precision is required:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"float_type(::Type{<:AbstractProblem})=Float64","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"We allow to also give objects instead of types:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"float_type(mop::mop_Type) where {mop_Type<:AbstractProblem}=float_type(mop_Type)","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Like with float_type, other properties are queried from the problem type, to enable type-based bridging. To this end, we have several attribute types:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"abstract type AbstractAttribute end\n\nstruct Variables <: AbstractAttribute end","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"A supertype for something that can be evaluated:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"abstract type AbstractFunctionQualifier <: AbstractAttribute end\n\nstruct Objectives <: AbstractFunctionQualifier end\nstruct LinEqConstraints <: AbstractFunctionQualifier end\nstruct LinIneqConstraints <: AbstractFunctionQualifier end\nstruct NonlinEqConstraints <: AbstractFunctionQualifier end\nstruct NonlinIneqConstraints <: AbstractFunctionQualifier end","category":"page"},{"location":"problem_interface/#Dimension-Information","page":"Problem Interface","title":"Dimension Information","text":"","category":"section"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Mandatory: Specialize dimval for Variables and other attributes as needed. For AbstractFunctionQualifiers, this should return Val{i}, where i is the integer dimension of output vectors.","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function dimval(\n    mop_Type::Type{<:AbstractProblem}, attr_Type::Type{<:AbstractAttribute})::Val\n    error(\"`dimval` not applicable for `$(mop_Type)` and `$(attr_Type)`.\")\nend\ndimval(::Type{<:AbstractProblem}, ::Type{<:AbstractFunctionQualifier})=Val(0)","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"We have some helpers that also take objects instead of types:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function dimval(_mop, _attr)\n    dimval(_typeof(_mop), _typeof(_attr))\nend\n_typeof(T::Type)=error(\"Cannot extract concrete type from `$T`.\")\n_typeof(T::DataType)=T\n_typeof(obj)=typeof(obj)","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"The integer dimension is returned by dim:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"dim(mop, attr)=_extract_val(dimval(mop, attr))\n_extract_val(::Val{i}) where {i} = i","category":"page"},{"location":"problem_interface/#Variable-Bounds","page":"Problem Interface","title":"Variable Bounds","text":"","category":"section"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"An attribute to indicate how variables are constrained:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"abstract type AbstractVarBoundsAttr <: AbstractAttribute end\nstruct NoBounds <: AbstractVarBoundsAttr end\nstruct LowerBounds <: AbstractVarBoundsAttr end\nstruct UpperBounds <: AbstractVarBoundsAttr end\nstruct BoxBounds <: AbstractVarBoundsAttr end","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Suggested: var_bounds defaults to NoBounds(); adapt as needed:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"var_bounds(::Type{<:AbstractProblem}) = NoBounds()\nvar_bounds(mop::mop_Type) where mop_Type<:AbstractProblem=var_bounds(mop_Type)","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"If var_bounds returns LowerBounds() or BoxBounds(), then lower_var_bounds should be implemented.","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function lower_var_bounds(mop::AbstractProblem)\n    return lower_var_bounds(var_bounds(mop), mop)\nend\nfunction lower_var_bounds(::Union{LowerBounds, BoxBounds}, mop)\n    error(\"`lower_var_bounds` not implemented.\")\nend","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Otherwise, we fall back to -∞:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function lower_var_bounds(var_bounds_attr, mop)\n    return _bounds_vec(dimval(mop, Variables), float_type(mop), mop, -Inf)\nend","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Likewise, implement upper_var_bounds if needed:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function upper_var_bounds(mop::AbstractProblem)\n    return upper_var_bounds(var_bounds(mop), mop)\nend\nfunction upper_var_bounds(::Union{UpperBounds, BoxBounds}, mop)\n    error(\"`upper_var_bounds` not implemented.\")\nend\nfunction upper_var_bounds(var_bounds_attr, mop)\n    return _bounds_vec(dimval(mop, Variables), float_type(mop), mop, Inf)\nend\n@generated function _bounds_vec(::Val{nvars}, ::Type{F}, mop, val) where {nvars, F}\n    return quote\n        Fval = convert($F, val)\n        fill(Fval, $nvars)\n    end\nend\n\nconst LinConstraints = Union{LinEqConstraints, LinIneqConstraints}","category":"page"},{"location":"problem_interface/#Linear-Constraints","page":"Problem Interface","title":"Linear Constraints","text":"","category":"section"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"If there are linear constraints, as indicated by dimval, you are advised to implement constraint_matrices. (There are bridges for 0-dim constraints and to fall back to calc).","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function constraint_matrices(mop::AbstractProblem, attr::LinConstraints)\n    # return (A, b) for constraints A ≤ b\n    # return (E, c) for constraints E = c\n    error(\"`constraint_matrices` not defined.\")\nend","category":"page"},{"location":"problem_interface/#Evaluation","page":"Problem Interface","title":"Evaluation","text":"","category":"section"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"If there are evaluators (as indicated by dimval), implement calc.\nFor linear inequality constraints A x  b, this should return the residual A - b.\nFor linear equality constraints E x = c, this should return the residual E - c.\nNonlinear constraints take the form g(x)  0 or h(x) = 0.\nThere are some bridges for 0-dim evaluators and to translate between matrices and vectors.","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function calc(\n    mop::AbstractProblem, attr::AbstractFunctionQualifier, x::AbstractVecOrMat\n)\n    error(\"`calc` not implemented.\")\nend","category":"page"},{"location":"problem_interface/#Differentiation","page":"Problem Interface","title":"Differentiation","text":"","category":"section"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Maybe implement the Jacobian:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function diff(\n    mop::AbstractProblem, attr::AbstractFunctionQualifier, x::AbstractVector\n)\n    error(\"`diff` not implemented.\")\nend","category":"page"},{"location":"problem_interface/#Internals","page":"Problem Interface","title":"Internals","text":"","category":"section"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Are there user defined methods?","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function is_implemented(\n    @nospecialize(func::func_Type),\n    @nospecialize(args_Type::Type{<:Tuple{mop_Type, Vararg}})\n) where {\n    mop_Type <: AbstractProblem,\n    func_Type <: Function\n}\n    m = static_which(func, args_Type, Val(false))\n    if isnothing(m)\n        return NotImplemented()\n    end\n    if m.sig.parameters[2] >: AbstractProblem\n        return NotImplemented()\n    end\n    return IsImplemented()\nend","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Is there an autodiff backend?","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function _backend_Type(::Type{<:AbstractProblem})\n    return Nothing\nend","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"If _backend_Type not Nothing, implement _backend accordingly:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function _backend(::AbstractProblem)\n    return nothing\nend","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"Show some info:","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"function Base.show(io::IO, mop::AbstractProblem)\n    mop_Type = typeof(mop)\n    show_problem(io, mop)\n    if !get(io, :compact, false)\n        print(io, \"\\n\\t| \")\n        print(io, \"Variables=$(dim(mop, Variables)), \")\n        print(io, \"VarBounds=$(var_bounds(mop_Type)), \")\n        print(io, \"Objectives=$(dim(mop, Objectives)), \")\n        print(io, \"\\n\\t| \")\n        print(io, \"LinEqConstraints=$(dim(mop, LinEqConstraints)), \")\n        print(io, \"LinIneqConstraints=$(dim(mop, LinIneqConstraints)), \")\n        print(io, \"NonlinEqConstraints=$(dim(mop, NonlinEqConstraints)), \")\n        print(io, \"NonlinIneqConstraints=$(dim(mop, NonlinIneqConstraints)) \")\n    end\nend\n\nfunction show_problem(io::IO, prop::AbstractProblem)\n    Base.show_default(io, prop)\nend","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"","category":"page"},{"location":"problem_interface/","page":"Problem Interface","title":"Problem Interface","text":"This page was generated using Literate.jl.","category":"page"}]
}
