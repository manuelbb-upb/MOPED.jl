<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bridging · MOPEDS.jl</title><meta name="title" content="Bridging · MOPEDS.jl"/><meta property="og:title" content="Bridging · MOPEDS.jl"/><meta property="twitter:title" content="Bridging · MOPEDS.jl"/><meta name="description" content="Documentation for MOPEDS.jl."/><meta property="og:description" content="Documentation for MOPEDS.jl."/><meta property="twitter:description" content="Documentation for MOPEDS.jl."/><meta property="og:url" content="https://manuelbb-upb.github.io/MOPEDS.jl/bridging_interface/"/><meta property="twitter:url" content="https://manuelbb-upb.github.io/MOPEDS.jl/bridging_interface/"/><link rel="canonical" href="https://manuelbb-upb.github.io/MOPEDS.jl/bridging_interface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MOPEDS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../problem_interface/">Problem Interface</a></li><li><a class="tocitem" href="../graph/">Hypergraph</a></li><li class="is-active"><a class="tocitem" href>Bridging</a><ul class="internal"><li><a class="tocitem" href="#Bridges"><span>Bridges</span></a></li><li><a class="tocitem" href="#BridgedWrapper"><span>BridgedWrapper</span></a></li><li><a class="tocitem" href="#Preparation-and-Computation"><span>Preparation and Computation</span></a></li><li><a class="tocitem" href="#Graph-Backed-Preparation"><span>Graph-Backed Preparation</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Bridging</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bridging</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/manuelbb-upb/MOPEDS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/manuelbb-upb/MOPEDS.jl/blob/main/docs/src/bridging_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Bridges"><a class="docs-heading-anchor" href="#Bridges">Bridges</a><a id="Bridges-1"></a><a class="docs-heading-anchor-permalink" href="#Bridges" title="Permalink"></a></h2><p>Every bridge has to subtype <code>AbstractBridge</code>:</p><pre><code class="language-julia hljs">abstract type AbstractBridge end</code></pre><p>For the shortest-path computation(s) in the bridging hyper-graph, the following methods should be implemented.</p><pre><code class="language-julia hljs">@nospecialize
&quot;&quot;&quot;
    is_implemented(
        bridge::AbstractBridge, func::Function, args_Type::Type{&lt;:Tuple})

Trait function to indicate if a method exists.&quot;&quot;&quot;
function is_implemented(
    bridge::AbstractBridge, func::func_Type, args_Type::Type{&lt;:Tuple}
) where func_Type &lt;: Function
    return NotImplemented()
end

&quot;&quot;&quot;
    required_funcs_with_argtypes(
        bridge::AbstractBridge, func::Function, args_Type::Type{&lt;:Tuple}
    )

Return an indexable iterable of function-args_Type tuples required by `bridge`.
&quot;&quot;&quot;
function required_funcs_with_argtypes(
    bridge::AbstractBridge, func::func_Type, args_Type::Type{&lt;:Tuple}
) where func_Type &lt;: Function
    return ()
end
@specialize</code></pre><p>Optionally, define a bridging cost:</p><pre><code class="language-julia hljs">@nospecialize
&quot;&quot;&quot;
    bridging_cost(
        bridge::AbstractBridge, func::Function, args_Type::Type{&lt;:Tuple}
    )

(Positive) cost of bridging with `bridge`.&quot;&quot;&quot;
function bridging_cost(
    bridge::AbstractBridge, func::func_Type, args_Type::Type{&lt;:Tuple}
) where func_Type &lt;: Function
    return 1.0
end
@specialize</code></pre><blockquote><p><strong>Note</strong></p><p>We use <code>args_Type</code> instead of <code>args...</code> here to enable investigating the graph without allocations. It is certainly more prohibitive because we must be able to infer enough information from types alone. But for now it appears sufficient.</p></blockquote><h2 id="BridgedWrapper"><a class="docs-heading-anchor" href="#BridgedWrapper">BridgedWrapper</a><a id="BridgedWrapper-1"></a><a class="docs-heading-anchor-permalink" href="#BridgedWrapper" title="Permalink"></a></h2><p>To enable bridges, implement <code>all_bridges</code> to return objects with types that subtype <code>AbstractBridge</code>:</p><pre><code class="language-julia hljs">all_bridges(obj) = ()</code></pre><p>This then enables us to build a minimal wrapper storing all the bridges, a type-stable graph, and a dict for quick retrieval of nodes for specific function calls (based on the call signature). <code>BridgedWrapper</code> is loosely inspired by the <code>LazyBridgeOptimizer</code> in <code>MathOptInterface</code>.</p><pre><code class="language-julia hljs">@kwdef struct BridgedWrapper{bridges_Type}
    bridges :: bridges_Type
    graph :: Graph = Graph()
    node_dict :: Dict{Tuple{Type, Type}, Node} = Dict{Tuple{Type, Type}, Node}()
end
&quot;&quot;&quot;
    BridgedWrapper(obj)

A wrapper around `obj` with bridges `all_bridges(obj)` enabled.
A `BridgedWrapper` can be used to efficiently query shortest paths.&quot;&quot;&quot;
BridgedWrapper(obj) = BridgedWrapper(; bridges = all_bridges(obj))</code></pre><p>More compact printing:</p><pre><code class="language-julia hljs">function Base.show(io::IO, bw::BridgedWrapper)
    println(io, &quot;BridgedWrapper(:bridges($(length(bw.bridges))), :graph, :node_dict)&quot;)
end</code></pre><p>Helper for resetting a wrapper. (We don&#39;t really support dynamically adding bridges as of yet.)</p><pre><code class="language-julia hljs">function reset!(bw::BridgedWrapper)
    empty!(bw.graph)
    empty!(bw.node_dict)
    return bw
end</code></pre><h3 id="Adding-Nodes-to-Wrapped-Graph"><a class="docs-heading-anchor" href="#Adding-Nodes-to-Wrapped-Graph">Adding Nodes to Wrapped Graph</a><a id="Adding-Nodes-to-Wrapped-Graph-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Nodes-to-Wrapped-Graph" title="Permalink"></a></h3><p>A node is only added for unimplemented function call signatures.</p><pre><code class="language-julia hljs">function node(
    bw::BridgedWrapper, @nospecialize(func::func_Type), @nospecialize(args_Type::Type)
) where func_Type &lt;: Function
    return node(is_implemented(func, args_Type), bw, func, args_Type)
end</code></pre><p><code>IsImplemented</code>, return trivial node:</p><pre><code class="language-julia hljs">function node(
    bw_impls_func::IsImplemented,
    bw::BridgedWrapper, @nospecialize(func::func_Type), @nospecialize(args_Type)
) where func_Type &lt;: Function
    return Node(0)
end</code></pre><p><code>NotImplemented</code>, actually add a node to the graph:</p><pre><code class="language-julia hljs">function node(
    bw_impls_func::NotImplemented,
    bw::BridgedWrapper, @nospecialize(func::func_Type), @nospecialize(args_Type)
) where func_Type &lt;: Function
    @unpack bridges, graph, node_dict = bw
    # is node already in graph?
    nd = _get(node_dict, func, args_Type, nothing)
    if !isnothing(nd)
        return nd
    end
    # create new node
    nd = add_node!(graph)
    # also store in dict
    _insert!(node_dict, func, args_Type, nd)

    # check if it is supported by any bridges:
    for (i, bridge) = enumerate(bridges)
        _maybe_add_bridge!(bw, nd, func, args_Type, i, bridge)
    end
    return nd
end</code></pre><p>Like with nodes, bridges/edges are only added if they support a certain function call.</p><pre><code class="language-julia hljs">function _maybe_add_bridge!(
    bw, nd, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge
) where func_Type
    is_implemented(bridge, func, args_Type)
    return _maybe_add_bridge!(
        is_implemented(bridge, func, args_Type), bw, nd, func, args_Type, i, bridge)
end</code></pre><p><code>NotImplemented</code>, do nothing:</p><pre><code class="language-julia hljs">function _maybe_add_bridge!(
    bridge_impls_func::NotImplemented,
    bw, nd, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge
) where func_Type
    return bw
end</code></pre><p><code>IsImplemented</code>, add hyper-edge to wrapped graph:</p><pre><code class="language-julia hljs">function _maybe_add_bridge!(
    bridge_impls_func::IsImplemented,
    bw, nd, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge
) where func_Type
    e = _edge(bw, func, args_Type, i, bridge)
    add_edge!(bw.graph, nd, e)
    return bw
end</code></pre><p>Helper to also add successor nodes; this is where recursion becomes obvious:</p><pre><code class="language-julia hljs">function _edge(
    bw, @nospecialize(func::func_Type), @nospecialize(args_Type), i, bridge
) where func_Type
    new_nodes = Node[
        node(bw, _func, _args_Type)
            for (_func, _args_Type) = required_funcs_with_argtypes(bridge, func, args_Type)
    ]
    bc = bridging_cost(bridge, func, args_Type)
    edge = Edge(i, new_nodes, bc)
    return edge
end</code></pre><h2 id="Preparation-and-Computation"><a class="docs-heading-anchor" href="#Preparation-and-Computation">Preparation and Computation</a><a id="Preparation-and-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Preparation-and-Computation" title="Permalink"></a></h2><p>When everything is set up, there is a two-stage execution procedure to actually perform a queried function call. First, some <code>AbstractPreparation</code> is instantiated. This object is then used to execute the function calls – with varying argument values (but not varying types or sizes). This is very similar to how <code>DifferentiationInterface</code> works. In fact, the fact that <code>prep</code> takes <code>args...</code> instead of <code>args_Type</code> is to enable bridges using <code>DifferentiationInterface</code>. (Otherwise, <code>prep</code> would also resemble <code>concrete_bridge_type</code> in <code>MathOptInterface</code>.)</p><pre><code class="language-julia hljs">abstract type AbstractPreparation end</code></pre><p>For a bridge to work, <code>prep</code> has to be specialized and return some <code>AbstractPreparation</code> object. The argument <code>bw</code> is needed to prepare successor calls/bridges:</p><pre><code class="language-julia hljs">@nospecialize
function prep(
    bridge::AbstractBridge, bw::BridgedWrapper, func::func_Type, args...
) where func_Type &lt;: Function
    error(&quot;`prep` not implemented for `$(bridge)` and `$(func)`.&quot;)
end
@specialize</code></pre><p>Then, <code>compute!</code> has to be specialized to return the value for <code>args...</code>:</p><pre><code class="language-julia hljs">@nospecialize
function compute!(prep::AbstractPreparation, args...)
    error(&quot;`compute!` not implemented for `$(prep)`.&quot;)
end
@specialize</code></pre><p>We can derive a compact helper:</p><pre><code class="language-julia hljs">function bridged_compute!(
    bw::BridgedWrapper, @nospecialize(func::func_Type), args...
) where func_Type &lt;: Function
    p = prep(bw, func, args...)
    return compute!(p, args...)
end</code></pre><h3 id="Default-Preparation-Objects"><a class="docs-heading-anchor" href="#Default-Preparation-Objects">Default Preparation Objects</a><a id="Default-Preparation-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Preparation-Objects" title="Permalink"></a></h3><p>When there is no path in the hyper-graph, an <code>UnsuccessfulPrep</code> is returned:</p><pre><code class="language-julia hljs">@kwdef struct UnsuccessfulPrep &lt;: AbstractPreparation
    msg :: Union{Nothing, String} = nothing
end

function UnsuccessfulPrep(@nospecialize(func::Function))
    msg = &quot;Call to `$(func)` not possible.&quot;
    UnsuccessfulPrep(; msg)
end</code></pre><p>It just errors:</p><pre><code class="language-julia hljs">function compute!(p::UnsuccessfulPrep, @nospecialize(args...))
    _compute_unsucc_prep(p.msg)
end
_compute_unsucc_prep(msg::String)=throw(ErrorException(msg))
_compute_unsucc_prep(::Nothing)=error(&quot;`compute!` not applicable for `UnsuccessfulPrep`.&quot;)</code></pre><p>If a function call is supported, then we just wrap the function:</p><pre><code class="language-julia hljs">struct FuncPrep{func_Type} &lt;: AbstractPreparation
    func :: func_Type
end</code></pre><p>This enables us to specialize <code>compute!</code> based on dispatch:</p><pre><code class="language-julia hljs">function compute!(@nospecialize(prep::FuncPrep), args...)
    @unpack func = prep
    return _compute_func_prep(func, args)
end</code></pre><p>In the end, we just <code>invoke</code> the function with arguments <code>args</code>:</p><pre><code class="language-julia hljs">function _compute_func_prep(@nospecialize(func::func_Type), args::args_Type) where {func_Type, args_Type}
    return invoke(func, args_Type, args...)
end</code></pre><h2 id="Graph-Backed-Preparation"><a class="docs-heading-anchor" href="#Graph-Backed-Preparation">Graph-Backed Preparation</a><a id="Graph-Backed-Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Backed-Preparation" title="Permalink"></a></h2><p>For a function call, a node is added (lazily), the shortest path is calculated (lazily), and a corresponding <code>AbstractPreparation</code> object is returned:</p><pre><code class="language-julia hljs">function prep(
    bw::BridgedWrapper, @nospecialize(func::func_Type), args...
) where {func_Type&lt;:Function}
    args_Type = typeof(args)
    n = node(bw, func, args_Type)
    if iszero(n.index)
        return FuncPrep(func)
    end
    _bellman_ford!(bw.graph)
    if isinf(bw.graph.dist[n.index])
        return UnsuccessfulPrep(func)
    end
    return prep_node(bw, n, func, args...)
end</code></pre><p><code>prep_node</code> is just a helper around <code>prep</code> for the best bridge (currently):</p><pre><code class="language-julia hljs">function prep_node(
    bw::BridgedWrapper, n::Node, @nospecialize(func::func_Type), args...
) where {func_Type&lt;:Function}
    bi = bw.graph.best[n.index]
    b = bw.bridges[bi]
    p = prep(b, bw, func, args...)
    return _prep_node(p, bw, n, func, args...)
end</code></pre><p>If preparation was successful, return <code>p</code>:</p><pre><code class="language-julia hljs">@nospecialize
function _prep_node(
    p::AbstractPreparation, bw::BridgedWrapper, n::Node, func::func_Type, args...
) where {func_Type&lt;:Function}
    return p
end
@specialize</code></pre><p>Otherwise, invalidate bridge and try again:</p><pre><code class="language-julia hljs">function _prep_node(
    @nospecialize(p), bw::BridgedWrapper, n::Node, @nospecialize(func::func_Type), args...
) where {func_Type&lt;:Function}
    ni = n.index
    bi = bw.graph.best[n.index]
    @unpack graph = bw
    es = graph.edges[ni]
    @debug &quot;Invalidating bridge $bi for node with index $ni.&quot;
    for (i, e) in enumerate(es)
        if e.bridge_index == bi
            _e = @set e.cost = Inf
            deleteat!(es, i)
            insert!(es, i, _e)
            # TODO modifying an array during iteration is dangerous
            #      alternative: make `Edge` mutable?
        end
    end
    graph.dist[ni] = Inf
    graph.last_correct_ref[] = ni - 1
    return prep(bw, func, args...)
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../graph/">« Hypergraph</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Monday 30 June 2025 10:20">Monday 30 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
